#pragma once
#define GLM_ENABLE_EXPERIMENTAL

#include <iostream>
#include <memory>
#include <vector>

#include <glm/geometric.hpp>
#include <glm/gtx/intersect.hpp>
#include <glm/gtx/norm.hpp>
#include <glm/vec3.hpp>

#include "Ray.hpp"
#include "Texture.hpp"
#include "BasicObject.hpp"
#include "Light.hpp"
#include "Inter.hpp"

//!  The BasicObject class.
/**
  Every object which has a physical meaning is deriving from this class.
  @sa PhysicalObject
*/
class BasicObject : public PhysicalObject {
public:
    //! A public variable.
    /**
      @brief color represents the color of the light-source. color elements are between
      0 and 1.
    */
    glm::vec3 color;

    //! A public variable.
    /**
      @brief The transparency helps determining how much light is refracted.
    */
    float transparency;

    //! A public variable.
    /**
      @brief The refactive index is used to compute refracted rays
    */
    float refractiveIndex;

    //! A public variable.
    /**
      @brief The reflexion index is the amount of light directly reflected.
    */
    float reflexionIndex;

    //! A public variable.
    /**
      @brief The amount of light which is diffused.
    */
    float albedo;

protected:
    /**
     * @brief The texture of the plane. Must have a getColor method defined.
     *
     */
    std::shared_ptr<Texture> texture;

    /**
     * @brief Egals to true if the texture is defined.
     *
     */
    bool hasTexture;

public:
    /**
     * @brief Getter to know if the texture is defined.
     *
     * @return true if the texture is defined
     * @return false if the texture is null
     */
    bool definedTexture() const { return this->hasTexture; }

    /**
     * @brief Get the Texture of the Plane
     *
     * @return std::shared_ptr<Texture>
     */
    std::shared_ptr<Texture> getTexture() const { return this->texture; };

    /**
     * @brief Set the Texture object
     *
     * @param text the incoming texture (as a shared_ptr object)
     */
    void setTexture(const std::shared_ptr<Texture> &text) {
        this->texture = text;
        this->hasTexture = true;
    }

    /**
     * @brief Computes the rays generated by the intersection between an object and a ray
     *
     * @param iRay the incoming ray
     * @param ltSrc the light source
     * @param inter the data about the intersection
     * @param rays the outgoing rays
     */
    virtual void intersect(const Ray &iRay, const std::shared_ptr<Light> &ltSrc, Inter &inter,
                           std::vector<Ray> &rays) const = 0;

    /**
     * @brief Construct a new Basic Object object
     *
     * @param pos the coordinates of the object
     * @param color the color of the object
     * @param t the transparency of the object
     * @param r the reflexion index of the object
     * @param R the refraction index of the object
     * @param a the albedo of the object
     */
    explicit BasicObject(glm::vec3 pos = glm::vec3(), glm::vec3 color = glm::vec3(1, 1, 1),
                         float t = 0, float r = 1, float R = 1, float a = 0.18)
        : PhysicalObject(pos),
          color(color),
          transparency(t),
          refractiveIndex(r),
          reflexionIndex(R),
          albedo(a),
          hasTexture(false) {}
};
